
## 1. 기본 구성과 문제점 ⚠️

처음에는 이전 사례와 비슷한 구성을 사용했다:
![[스크린샷 2025-05-07 오후 11.09.25.png]]
- Route 53 DNS
- 다중 AZ ELB(Elastic Load Balancer)
- 여러 AZ에 분산된 EC2 인스턴스들과 오토 스케일링 그룹

**핵심 문제**:

- 사용자가 장바구니에 상품을 담은 후, 다른 요청이 다른 EC2 인스턴스로 라우팅되면 장바구니 정보가 사라짐
- 사용자 입장에서는 매번 장바구니가 초기화되는 것처럼 보임 😱
- 결국 안 좋은 사용자 경험으로 인해 고객 이탈 발생

## 2. 세션 관리 방식 4가지 비교 📊

### 2.1 ELB 고착도(Stickiness) 활용 🧲

![[스크린샷 2025-05-07 오후 11.10.17.png]]

**원리**:

- ELB에서 세션 고착도 활성화
- 사용자의 모든 요청을 항상 동일한 EC2 인스턴스로 라우팅

**장점**:

- 구현이 간단함
- 애플리케이션 코드를 수정할 필요 없음

**단점**:

- EC2 인스턴스가 종료되면 장바구니 데이터 완전히 손실
- 인스턴스 간 부하 불균형 발생 가능
- 특정 인스턴스에 트래픽이 몰릴 경우 성능 저하

**Note** 💡 ELB 고착도는 쿠키를 기반으로 동작하며, Application Load Balancer에서 사용할 수 있다. 고착도 기간은 1초부터 7일까지 설정 가능하다

### 2.2 웹 쿠키를 통한 클라이언트 측 세션 저장 🍪

![[스크린샷 2025-05-07 오후 11.11.10.png]]

**원리**:

- 장바구니 정보를 사용자의 브라우저 쿠키에 직접 저장
- 사용자가 요청을 보낼 때마다 쿠키를 함께 전송

**장점**:

- 완전한 무상태 설계 가능
- 서버 측 저장소 불필요
- 어떤 EC2 인스턴스로 요청이 가도 동일하게 작동

**단점**:

- 쿠키 크기 제한(4KB)으로 대용량 장바구니 저장 불가
- HTTP 요청 크기 증가로 네트워크 비용 증가
- 사용자가 쿠키를 조작할 수 있어 보안 위험 존재
- 서버에서 반드시 쿠키 검증 필요

### 2.3 서버 세션 + ElastiCache 조합 🗄️

![[스크린샷 2025-05-07 오후 11.12.53.png]]
**원리**:

- 사용자에게는 세션 ID만 쿠키로 제공
- 실제 장바구니 데이터는 ElastiCache에 저장
- EC2 인스턴스는 세션 ID를 키로 사용해 캐시에서 데이터 조회

**장점**:

- 1ms 미만의 빠른 응답 시간
- 보안성 향상(사용자가 데이터 직접 조작 불가)
- 쿠키 크기 최소화
- 복잡한 장바구니 데이터 저장 가능

**단점**:

- ElastiCache 구성 및 관리 필요
- 약간의 복잡성 증가

**핵심 포인트!** 📝 ElastiCache는 Redis 또는 Memcached를 관리형 서비스로 제공하며, 인메모리 캐싱으로 데이터 액세스 지연 시간을 크게 줄일 수 있다. Redis를 선택하면 다중 AZ 구성도 가능하다

### 2.4 DynamoDB를 이용한 세션 저장 (추가 옵션) 📚

**원리**:

- ElastiCache 대신 DynamoDB에 세션 데이터 저장
- 세션 ID를 파티션 키로 사용하여 데이터 저장/조회

**장점**:

- 서버리스 아키텍처 구성 가능
- 자동 스케일링 및 관리 용이성
- 내구성이 높음(데이터 지속성)

**단점**:

- ElastiCache보다 약간 느린 응답 속도
- 비용이 더 발생할 수 있음

## 3. 사용자 데이터 저장 - RDS 활용 

![[스크린샷 2025-05-07 오후 11.13.52.png]]

장바구니 외에도 사용자 주소, 이름 등의 영구적인 정보를 저장해야 한다:

**구성**:

- Amazon RDS를 사용한 데이터베이스 구축
- EC2 인스턴스에서 RDS로 직접 연결하여 데이터 CRUD 수행

**이점**:

- 장기적인 데이터 저장 가능
- 트랜잭션 지원
- 백업 및 복구 기능

## 4. 읽기 성능 향상 방법 🔍

사용자들이 대부분의 시간을 상품 정보 브라우징에 사용한다면:

### 4.1 RDS 읽기 전용 복제본 활용

![[스크린샷 2025-05-07 오후 11.14.36.png]]
**원리**:

- 마스터 RDS는 쓰기 작업만 처리
- 최대 5개의 읽기 전용 복제본 생성
- 읽기 요청은 복제본으로 분산

**장점**:

- 읽기 쿼리의 확장성 크게 향상
- 마스터 DB의 부하 감소
- 리전 간 복제를 통한 지연 시간 감소 가능

### 4.2 ElastiCache를 활용한 데이터 캐싱

![[스크린샷 2025-05-07 오후 11.15.06.png]]

**원리**:

- 자주 요청되는 데이터를 ElastiCache에 저장
- 캐시 미스 시에만 RDS에서 데이터 조회 
- 조회된 데이터는 캐시에 저장하여 재사용

**장점**:

- RDS 부하 대폭 감소
- 밀리초 단위의 응답 시간
- 사용자 경험 향상

**캐시 전략** 💡 Lazy Loading(지연 로딩) 또는 Cache-Aside 패턴이라고 불리는 캐싱 전략

1. 데이터 요청 시 먼저 캐시 확인
2. 캐시에 없으면(캐시 미스) DB에서 데이터 조회
3. DB에서 가져온 데이터를 캐시에 저장
4. 이후 동일 데이터 요청 시 캐시에서 즉시 제공(캐시 히트)

## 5. 고가용성 및 재해 복구 구성 🛡️

안정적인 서비스 제공을 위한 다중 구성:

![[스크린샷 2025-05-07 오후 11.16.07.png]]

**다중 AZ 구성 요소**:

- Route 53: 이미 고가용성 설계
- ELB: 다중 AZ 구성
- EC2: 오토 스케일링 그룹으로 다중 AZ 관리
- RDS: 다중 AZ 및 자동 장애 조치 설정
- ElastiCache: Redis 사용 시 다중 AZ 구성 가능

**재해 복구 강화**:

- RDS 읽기 전용 복제본을 다른 리전에 배치하여 리전 장애 대비
- 다중 리전 배포 고려(글로벌 사용자 기반인 경우)

## 6. 보안 강화 방안 🔒

각 계층별 보안 그룹 설정:

![[스크린샷 2025-05-07 오후 11.16.43.png]]

1. **ELB 보안 그룹**:
    - 인바운드: 전체 인터넷에서 HTTP/HTTPS 허용
    - 아웃바운드: EC2 인스턴스로만 통신 허용
2. **EC2 보안 그룹**:
    - 인바운드: ELB 보안 그룹에서 오는 트래픽만 허용
    - 아웃바운드: ElastiCache 및 RDS 보안 그룹으로만 통신 허용
3. **ElastiCache 보안 그룹**:
    - 인바운드: EC2 보안 그룹에서 오는 트래픽만 허용
4. **RDS 보안 그룹**:
    - 인바운드: EC2 보안 그룹에서 오는 트래픽만 허용

**추가 보안 기능** 🔐 웹 애플리케이션 방화벽(WAF)을 ELB 앞에 배치하여 SQL 인젝션, XSS 공격 등을 방어할 수 있다. 또한 AWS Shield를 사용하여 DDoS 공격으로부터 보호할 수 있다

## 7. 아키텍처 종합 평가 ⚖️

**3-티어 아키텍처 완성**:

- 클라이언트 티어: 사용자와 웹 브라우저
- 웹 티어: ELB, EC2 인스턴스, 오토 스케일링
- 데이터베이스 티어: ElastiCache, RDS

**트레이드오프**:

- 비용 증가 ↔ 안정성 및 확장성 향상
- 복잡성 증가 ↔ 기능 및 성능 향상


## 9. 요약: 핵심 포인트 📌

1. **세션 관리 방식 선택이 중요**:
    - 단순함을 원하면 ELB 고착도
    - 완전한 무상태를 원하면 쿠키 기반
    - 성능과 보안을 모두 원하면 ElastiCache + 세션 ID
2. **데이터 계층화로 성능 최적화**:
    - 휘발성 데이터(세션, 장바구니): ElastiCache
    - 영구 데이터(사용자 정보): RDS
    - 읽기 많은 데이터: 읽기 전용 복제본 또는 캐싱
3. **다중 AZ 구성으로 고가용성 확보**:
    - 모든 계층에서 다중 AZ 구성
    - 장애 발생 시에도 서비스 연속성 보장
4. **보안을 계층화**:
    - 보안 그룹 간 참조로 최소 권한 원칙 적용
    - 각 계층별 접근 제한으로 공격 표면 최소화

이렇게 구성된 상태 유지 웹 애플리케이션은 확장성, 가용성, 보안성을 모두 갖추게 되며, 사용자에게 일관된 경험을 제공할 수 있게 된다 물론 이러한 아키텍처는 비용과 복잡성이 증가하지만, 그에 상응하는 가치를 제공한다