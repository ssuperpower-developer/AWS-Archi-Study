
## 🌟 AWS의 로드 밸런서 유형

AWS에는 **3가지 유형의 관리형 로드 밸런서**가 있다.
clb는 더이상 지원되지 않는다.

1. **Application Load Balancer (v2 - 신세대)** - 2016년 - ALB
    - HTTP, HTTPS, WebSocket 지원
2. **Network Load Balancer (v2 - 신세대)** - 2017년 - NLB
    - TCP, TLS (보안 TCP), UDP 지원
3. **Gateway Load Balancer** - 2020년 - GWLB
    - 레이어 3(네트워크 레이어) - IP 프로토콜에서 작동


osi7 layer을 생각하면 이해가 빠르다. 
ALB는 7계층까지 본다 그렇기 때문에 
url에 있는 쿼리에 따라서, 헤더, 경로에 따라서 서버로 라우팅이 되는 것이다. 
그렇기 때문에 MSA에 최적화 되어있다.

NLB는 TCP/UDP 계층으로 4계층에서 작동을 하기 때문에 패킷의 내용을 깊게 들여다보지 않는다. 

**ALB vs NLB 비교**:

- ALB (L7): "이 HTTP 요청의 URL이 뭐지? 헤더는? 쿠키는? 본문은?" → 분석하느라 시간 소요
- NLB (L4): "어디서 왔고 어디로 가는 패킷이네. 보내!" → 단순해서 빠름

**비유를 해보자면**

- ALB는 편지의 내용까지 다 읽고 분류하는 우체국 직원
- NLB는 주소만 보고 빠르게 분류하는 자동 분류기

NLB는 속도가 생명인 곳에 적용을 할 수가 있다. 
예를 들어서 주식 단타, 스캘핑 주문, 혹은 게임 서버 같이 속도가 중요한 곳에 배치가 된다. 

NLB는 라운드 로빈 (돌아가면서 나눠주기)나 Least Connections(가장 한가한 서버에게 일주기), 흐름 해시 (같은 클라이언트의 요청은 같은 서버로 가도록 보장) 같은 단순한 처리를 통해 서버로 라우팅을 한다.

**Gateway Load Balancer** 

방화벽이나 침입 탐지 및 방지 시스템에 사용한다.

![[스크린샷 2025-05-03 오후 9.36.12.png]]

라우팅 테이블이 수정되면 먼저, 모든 사용자 트래픽은 GWLB를 통과한다. 그리고 GWLB는 가상 어플라이언스의 대상 그룹 전반으로 트래픽을 확산한다. 그래서 모든 트래픽은 어플라이언스에 도달하고 어플라이언스는 트래픽을 분석하고 처리한다. 방화벽이나 침입 탐지 같은 것이다. 이상이 없으면 다시 GWLB로 보내고 이상이 있으면 트래픽을 드롭한다. 이상이 없을 때 이제 Application에 도달하는 것이다. 

"모든 트래픽을 보안 장비로 보내서 검사받게 하는 것이 주 목적이다."

## Elastic Load Balancer 

AWS 의 로드 밸런싱 서비스의 총칭이다. 

"나 ELB 써" = "나 AWS 로드 밸런서 써" (어떤 종류인지는 모름)

구체적인 로드 밸런서 유형에 ALB, NLB, GWLB가 있는 것이다.


#### Sticky Sessions 
같은 클라이언트가 항상 로드 밸런서 뒤의 같은 인스턴스로 리다이렉션 되도록 고정성을 구현할 수있다. 
이는 CLB, ALB, NLB 모두에서 작동한다.

-> 사용자가 세션 데이터를 잃지 않도록 하기 위함이다.

쿠키에는 2가지가 있다. 
1. 애플리케이션 쿠키 (Application-based Cookies)
	1. custom cookie
		1. 어플리케이션 자체에서 생성하는 사용자 정의 쿠키이다. 
		2. 쿠키 이름은 각 대상 그룹에 대해 개별적으로 지정해야 한다. 
	2. Application cookie
		1. load balancer에 의해서 생성이 된다. 
2. 지속 시간 기반 쿠키 
	1. 로드밸런서에 의해 생성이 된다. 
	2. 이 쿠키는 특정 지속 시간에 따라 만료된다. 

## 🌐 교차 영역 로드 밸런싱

**교차 영역 로드 밸런싱이 있는 경우**:

- 각 로드 밸런서 인스턴스는 모든 AZ에 등록된 모든 인스턴스에 균등하게 분산한다.

**교차 영역 로드 밸런싱이 없는 경우**:

- 요청은 Elastic Load Balancer 노드의 인스턴스로만 분산돼요!

![[스크린샷 2025-05-03 오후 9.49.22.png]]

## 🔄 교차 영역 로드 밸런싱 - 서비스별 설정

**Application Load Balancer**:

- 기본적으로 활성화돼 있음 (대상 그룹 수준에서 비활성화 가능)
- AZ 간 데이터 전송에 대한 요금 없음

**Network Load Balancer & Gateway Load Balancer**:

- 기본적으로 비활성화됨
- 활성화하면 AZ 간 데이터에 대한 요금($)이 부과됨
	- 가용 영역 사이에서 데이터를 옮기려면 비용이 발생하기 때문이다. 

**Classic Load Balancer**:

- 기본적으로 비활성화됨
- 활성화해도 AZ 간 데이터에 대한 요금 없음

## 🔐 SSL/TLS - 기본 개념

SSL 인증서를 사용하면 클라이언트와 로드 밸런서 간의 트래픽이 전송 중에 암호화될 수 있어요 (전송 중 암호화)! 마치 우편물을 특수 봉투에 넣어 내용이 노출되지 않게 하는 것과 같아요! ✉️

- **SSL**은 Secure Sockets Layer를 의미하며, 연결을 암호화하는 데 사용돼요
- **TLS**는 Transport Layer Security를 의미하며, 더 새로운 버전이에요
- 요즘은 주로 **TLS 인증서**가 사용되지만, 사람들은 여전히 SSL이라고 부르는 경우가 많아요
- 공개 SSL 인증서는 인증 기관(CA)에서 발급해요:
    - Comodo, Symantec, GoDaddy, GlobalSign, Digicert, Letsencrypt 등
- SSL 인증서에는 만료 날짜(직접 설정)가 있으며 갱신해야 해요!

## 📜 로드 밸런서 - SSL 인증서

로드 밸런서는 X.509 인증서(SSL/TLS 서버 인증서)를 사용해요!

ACM(AWS Certificate Manager)을 사용하여 인증서를 관리할 수 있어요!

또는 자체 인증서를 업로드할 수도 있어요!

**HTTPS 리스너**:

- 기본 인증서를 지정해야 해요
- 여러 도메인을 지원하기 위해 선택적으로 인증서 목록을 추가할 수 있어요
- 클라이언트는 SNI(Server Name Indication)를 사용하여 도달하려는 호스트 이름을 지정할 수 있어요
- 이전 버전의 SSL/TLS(레거시 클라이언트)를 지원하기 위한 보안 정책을 지정할 수 있어요

## 🔒 SSL - Server Name Indication (SNI)

SNI는 하나의 웹 서버에 **여러 SSL 인증서**를 로드하는 문제를 해결해요 (여러 웹사이트를 제공하기 위해)!

이것은 "더 새로운" 프로토콜이며, 클라이언트가 초기 SSL 핸드셰이크에서 대상 서버의 호스트 이름을 **표시**해야 해요!

그러면 서버는 올바른 인증서를 찾거나 기본 인증서를 반환해요!

**참고**:

- ALB & NLB(신세대)와 CloudFront에서만 작동해요
- CLB(구세대)에서는 작동하지 않아요

## 📜 Elastic Load Balancers - SSL 인증서 유형별 지원

**Classic Load Balancer (v1)**:

- 하나의 SSL 인증서만 지원해요
- 여러 SSL 인증서로 여러 호스트 이름을 사용하려면 여러 CLB가 필요해요

**Application Load Balancer (v2)**:

- 여러 SSL 인증서로 여러 리스너 지원
- 이를 위해 Server Name Indication (SNI) 사용

**Network Load Balancer (v2)**:

- 여러 SSL 인증서로 여러 리스너 지원
- 이를 위해 Server Name Indication (SNI) 사용

## 🚪 Connection Draining

**기능 이름**:

- CLB의 경우 **Connection Draining**
- ALB & NLB의 경우 **Deregistration Delay**

인스턴스가 등록 취소되거나 비정상인 동안 "진행 중인 요청"을 완료하기 위한 시간이에요! 마치 가게를 닫기 전에 아직 안에 있는 손님들이 쇼핑을 마칠 수 있게 기다리는 것과 같아요! 🛍️

등록 취소 중인 EC2 인스턴스로 새 요청을 보내는 것을 중지해요!

1~3600초 사이 (기본값: 300초)

비활성화할 수 있어요 (값을 0으로 설정)

요청이 짧다면 낮은 값으로 설정하세요!