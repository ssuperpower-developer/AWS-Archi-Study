>Lambda, API Gateway, DynamoDB와 Cognito 
>
>AWS Certified Solutions Architect 시험은 서버리스 서비스 관련 비중이 높지 않기 때문에 이 섹션만으로도 시험 대비로는 충분할 것입니다.

---
# 215. 서버리스 소개

- **서버리스(Serverless)**: 개발자가 **서버를 직접 관리하지 않아도 되는 서비스 모델**
- **서버가 없다는 의미는 아니고**, 단지 **보이지 않거나 직접 프로비저닝할 필요가 없다는 뜻**입니다.
- 초기에는 **FaaS(Function as a Service)**를 의미했지만, **지금은 더 넓은 범위**를 포함합니다.

### **서버리스의 구성 요소 (AWS 중심 예시)**
- **정적 콘텐츠** → S3, CloudFront
- **인증/인가** → Cognito
- **API 처리** → API Gateway + Lambda
- **데이터 저장/조회** → DynamoDB
- **메시징** → SNS, SQS
- **데이터 처리** → Kinesis Data Firehose
- **서버리스 DB** → Aurora Serverless
- **컨테이너 실행** → AWS Fargate (서버리스 컨테이너)
    


###  **특징**
- ==**자동 스케일링**, **사용한 만큼 과금**==
- ==**서버 프로비저닝이 필요 없음**==
    
---

# 216. 람다 개요

**AWS Lambda란?**  
- AWS Lambda는 **서버를 직접 관리하지 않고 코드를 실행할 수 있는 서버리스 컴퓨팅 서비스
- 이벤트 기반으로 동작하며, 호출될 때만 실행되고 비용도 실행 시간과 호출 수에 따라 발생

---

### **전통적인 서버 방식 (Amazon EC2)와 비교**
- EC2는 **가상 서버**를 사용해 프로비저닝해야 하며, 항상 실행 중
- 확장 시에도 직접 자동 확장 그룹을 구성해야 함.
- 사용하지 않아도 비용이 발생합니다.

### **Lambda의 주요 특징**

- **서버리스**: 서버 관리 불필요, 코드만 있으면 됨.
- **이벤트 기반 실행**: 호출될 때만 실행 (최대 15분).
- **자동 확장**: 요청량 증가 시 Lambda가 자동 확장됨.
- **비용 효율성**:
    - 월 100만 건의 요청, 40만 GB-초 무료
    - 이후 요청 100만 건당 $0.20
    - 실행 시간과 메모리 사용량에 따라 추가 요금
        

### **지원 언어**
- ==Node.js, Python==, Java, C#, PowerShell, Ruby 등 
- Rust, Go 등도 **커스텀 런타임 API**로 가능
- **컨테이너 이미지** 기반 실행도 지원 (단, Docker 기반이라면 EKS/Fargate가 시험에는 더 적절)
    

### **AWS 서비스와의 통합 예시**

- **API Gateway** → REST API 요청 시 Lambda 호출
- **Kinesis** → 실시간 데이터 처리
- **DynamoDB** → 데이터 변경 시 트리거
- **S3** → 파일 업로드 등 이벤트 발생 시 Lambda 실행
- **CloudFront** → Lambda@Edge
- **CloudWatch / EventBridge** → 이벤트 기반 자동화
- **SNS / SQS / Cognito** 등 다양한 AWS 서비스와 연결 가능
    

### **활용 예시**

1. **썸네일 자동 생성**
    - S3에 이미지 업로드 → Lambda 실행 → 썸네일 생성 및 저장
    - 메타데이터를 DynamoDB에 저장
        ![[스크린샷 2025-05-14 오후 9.28.27.png]]
2. **서버리스 크론 작업**
    - 예: 매주 월요일 10시 실행
    - CloudWatch 이벤트 + Lambda로 EC2 없이도 가능
		![[스크린샷 2025-05-14 오후 9.28.43.png]]
---

### **Lambda 과금 구조**
- 요청 수 + 실행 시간(GB-초 기준)
- 예: 128MB 메모리 사용 시 1GB보다 8배 더 긴 실행 시간 가능    
- **매우 저렴하며** 소규모 또는 이벤트 기반 애플리케이션에 적합
    

---

**결론**:  
- AWS Lambda는 서버 관리 없이, 자동 확장되는 서버리스 환경에서 이벤트 기반으로 코드를 실행할 수 있는 서비스
- 다양한 AWS 서비스와 쉽게 통합되며 높은 유연성과 비용 효율성을 제공


# 218. 람다 limit

### AWS Lambda 한도 요약 (시험 대비)

#### **실행 한도**

- **메모리**: ==128MB ~ 10GB== (1MB 단위로 증가)    
- **vCPU**: 메모리 증가에 따라 자동 증가
- **최대 실행 시간**: 900초 ==(15분)==
- **환경변수 크기**: 최대 4KB
- **임시 저장소 (`/tmp`)**: 최대 10GB
- **동시 실행 수**: 기본 1,000개 (요청 시 증가 가능, 예약 권장)
    

#### **배포 한도**
- **패키지 크기**:
    - 압축 시: 최대 50MB        
    - 비압축 시: 최대 250MB
- **대용량 파일 처리**: `/tmp` 디렉터리 활용
- **환경변수 크기** (배포 시 포함): 최대 4KB
    

####  **판단 기준 예시**
- RAM 30GB, 실행 시간 30분, 3GB 파일 → Lambda **부적합**
    

# 219. 람다 SnapStart

- **대상**: Java 11 이상 Lambda 함수    
- **장점**: 추가 비용 없이 **최대 10배 성능 향상**
    

####  작동 방식
- Lambda 함수의 **초기화 단계를 미리 수행**
- 초기화된 함수의 **메모리 및 디스크 상태를 스냅샷**으로 저장
- 이 스냅샷을 **저지연 캐시에 보관**
- 이후 호출 시 → 초기화 없이 **즉시 실행 가능**

#### **수명 주기 변화**
- 일반 Java Lambda:
    - 호출 → 초기화(init) → 실행 → 종료
- Snap Start 적용 시:
    - **초기화 생략** → 실행 → 종료
    
####  **활성화 조건**
- **Lambda 버전 발행 시 자동 초기화 및 스냅샷 생성**
- **Snap Start를 설정해야 작동**    

결론: Java 기반 Lambda의 콜드 스타트 지연을 대폭 줄여주므로, 시험 및 실무에서 유용하게 활용할 수 있음.


# 220. 람다@엣지 & CloudFront Functions

- 일반 Lambda 함수는 **리전 기반**으로 동작
- **엣지 로케이션**에서 콘텐츠를 제공
	- 사용자랑 가까운곳에서 작업을 처리해서 지연시간을 최소화 할 수 있다.

---
### CloudFront Functions

- **런타임**: JavaScript
- **위치**: 뷰어 요청(Viewer Request), 뷰어 응답(Viewer Response)만 수정 가능
- **특징**:
    - 고성능, 고확장성 (초당 수백만 요청 처리)
    - 시작 시간 1ms 미만        
    - 캐시 키 정규화, 헤더 조작, 리디렉션, 인증(JWT) 등 간단한 작업에 적합
    - **CloudFront에서 직접 관리 (서버리스)**

---

### Lambda@Edge

- **런타임**: Node.js, Python
- **위치**:
    - 뷰어 요청 / 응답
    - 오리진 요청 / 응답 **모두 수정 가능**
- **특징**
    - 실행 시간 수 초(5~10초), 복잡한 로직 가능
    - 외부 서비스 통신, 파일 시스템 접근, AWS SDK 사용 가능
    - 복잡한 사용자 인증, 데이터 통합, 동적 페이지 처리 등 적합

---

### 🔸 비교 요약표

| 항목              | CloudFront Functions | Lambda@Edge     |
| --------------- | -------------------- | --------------- |
| **런타임**         | JavaScript           | Node.js, Python |
| **확장성**         | 매우 높음 (백만 단위)        | 높음 (수천 단위)      |
| **트리거 지점**      | 뷰어 요청/응답만            | 뷰어 + 오리진 모두     |
| **실행 시간**       | 1ms 미만               | 최대 10초          |
| **복잡한 작업**      | 불가능                  | 가능              |
| **타사 라이브러리**    | 불가능                  | 가능              |
| **네트워크/SDK 접근** | 불가능                  | 가능              |

---

### 🔸 주요 사용 사례

|CloudFront Functions|Lambda@Edge|
|---|---|
|빠른 JWT 인증|복잡한 사용자 인증/권한 처리|
|URL 리디렉션|외부 API와 통신하여 응답 생성|
|캐시 키 정규화|동적 콘텐츠 렌더링, 실시간 데이터 처리|
|HTTP 헤더 조작|SEO 최적화, A/B 테스트, 실시간 이미지 변환|

---

엣지에서의 사용자 경험을 향상시키기 위한 강력한 도구
- 경량 고속 처리는 **CloudFront Functions**
- 복잡한 로직은 **Lambda@Edge**

# 221. 람다 in VPC

- **기본 설정**: 
	- Lambda 함수는 기본적으로 **VPC 외부**에서 실행
	- VPC 내의 **RDS**나 **ElastiCache**와 같은 리소스에 접근할 수 없음
	- ==퍼블릭 API나 **DynamoDB**==는 접근 가능
    
- **VPC에서 Lambda 함수 실행**:    
    - Lambda를 **VPC 내**에서 실행하면 VPC 리소스에 접근할 수 있습니다. 이를 위해 **VPC ID**, **서브넷**, 그리고 **보안 그룹**을 지정해야 합니다.
    - Lambda 함수가 **Elastic Network Interface**(ENI)를 생성하여 VPC 내의 리소스에 액세스할 수 있게 됩니다.
        
- **Lambda와 RDS 연결 문제**:
    - Lambda 함수가 RDS 데이터베이스에 직접 연결하면, 함수의 수가 많아져 **연결 초과**나 **시간 초과** 문제가 발생할 수 있습니다.
        
- **RDS 프록시 사용**:
    - RDS 프록시는 연결을 풀링하고 공유하여 **확장성**을 향상시키며, 장애 발생 시 장애 조치 시간을 **66%까지 단축**합니다.
    - RDS 프록시를 사용하면 Lambda 함수는 RDS에 직접 연결하지 않고, 프록시를 통해 연결하여 문제를 해결합니다.
        
- **IAM 인증과 보안**:
    - RDS 프록시는 **IAM 인증**을 강제하여 보안을 강화하고, 자격 증명은 **Secrets Manager**에 저장됩니다.
        
- **결론**:
    - Lambda 함수가 RDS 프록시에 연결하려면 **VPC 내에서 실행**해야 합니다. **퍼블릭 Lambda**는 RDS 프록시와 연결할 수 없습니다.

# 222. RDS - 람다 호출 및 이벤트 알림




# 223. Amazon DynamoDB
- **완전 관리형 NoSQL 데이터베이스**
- 복잡한 설치, 관리, 백업 없이도 사용할 수 있음
- **엄청 빠르고, 자동으로 확장되고, 장애에 강함
- AWS 독점


### **특징 및 장점**

- 초당 수백만 개 요청 처리, 수조 개의 항목 저장 가능
- **한 자릿수 밀리초 성능** + 높은 일관성
- **IAM 통합**으로 보안 및 권한 관리
- **유지보수 불필요**, **프로비저닝 필요 없음**
- **오토스케일링 기능 내장**


###  **데이터 구조**
- **데이터베이스 대신 테이블 생성**
- **기본 키 필수** (파티션 키, 선택적 정렬 키)    
- **속성은 열에 해당**, 나중에 추가 가능, `null` 허용
- **항목 크기 제한: 400KB**

### **지원 데이터 유형**
- **스칼라**: 문자열, 숫자, 바이너리, 불리언, null
- **문서형**: List, Map
- **세트형**: 문자열 세트, 숫자 세트 등

### **테이블 클래스**
- **Standard**: 빈번한 액세스용
- **IA (Infrequent Access)**: 드물게 액세스되는 데이터용
    

---

### **용량 모드**

1. **프로비저닝된 모드**
    - 용량(RCU/WCU) 사전 설정
    - 오토 스케일링 가능        
    - 비용 절감에 적합
    - ==예측 가능, 비용 중요==
        
2. **온디맨드 모드**
    - ==빠른 자동 확장==
    - 사용량만큼 비용 지불
    - 예측 불가능하거나 급격히 증가하는 워크로드에 적합
    - ==트랜잭션 적음 + 간혈적 사용==
    


---
# 심화 개념
### 1. **DAX (DynamoDB Accelerator)**

- DynamoDB용 **완전 관리형 인메모리 캐시**
- **읽기 성능 개선**: 마이크로초 단위 지연 시간 제공
- **API 호환성 유지**: 기존 애플리케이션 로직 변경 없이 사용 가능
- **기본 TTL은 5분**이며, 조정 가능
- ElastiCache보다 DAX를 사용하는 이유:
    - **객체 캐시 + 쿼리/스캔 캐시** 지원
    - DynamoDB와의 통합성이 뛰어남
    

### 2. **DynamoDB Streams**
- 테이블의 **생성/업데이트/삭제 이벤트 스트리밍**
- **실시간 반응형 처리** 가능 (예: Lambda로 이메일 발송)
- 두 종류 존재:
    1. **DynamoDB Streams**: 24시간 보존, 제한된 소비자 수
    2. **Kinesis Data Streams** 연동: 1년 보존, 다수 소비자, 다양한 처리 옵션 지원
        
- 연동 가능한 서비스:
    - Lambda, Kinesis Data Analytics, Firehose, Glue, OpenSearch 등
        

### 3. **글로벌 테이블**
- **다중 리전 간 양방향 복제** 가능
- 각 리전에서 **읽기/쓰기 모두 가능**
- 스트림 기능이 활성화되어 있어야 복제 가능


### 4. **TTL (Time to Live)**
- 설정된 **만료 시간**이 지나면 항목 자동 삭제
- 주 사용 사례:
    - **세션 관리** (예: 2시간 후 세션 자동 만료)
    - **보존 기간 정책 준수**
    

### 5. **백업 및 복구**
- **PITR (지정 시간 복구)**: 최근 35일 내 특정 시점으로 복구 가능 (새 테이블 생성)
- **온디맨드 백업**: 수동 백업, 직접 삭제 전까지 보존
- **AWS Backup 통합**: 백업 수명 주기 및 리전 간 복사 지원


### 6. **Amazon S3 통합**
- **DynamoDB → S3 내보내기**: 데이터 분석 또는 스냅샷 확보
- **Athena 쿼리 가능**
- DynamoDB 성능에 영향 없음
- **S3 → DynamoDB 가져오기**도 가능 (CSV, JSON, ION 지원)

# 226. API Gateway

### Lambda와 DynamoDB
- Lambda 함수에서 DynamoDB를 데이터베이스로 사용 가능
- 테이블 생성, 조회, 수정, 삭제 가능

### 클라이언트에서 Lambda 호출
- 클라이언트가 Lambda를 직접 호출하려면 IAM 권한 필요
- Lambda 앞에 **애플리케이션 로드 밸런서**나 **API Gateway** 배치 가능
    

### API Gateway의 필요성과 기능
- Lambda와 연동해 완전한 서버리스 REST API 구축
- 실시간 스트리밍 (WebSocket), 버전 관리, 환경별 분리(dev/test/prod) 지원
- 보안 기능 제공 (인증, 권한, API 키, 요청 제한 등)
- Swagger/OpenAPI로 API 설계 및 배포 가능
- 요청/응답 가공, 캐싱, SDK 생성 등 다양한 부가 기능 제공
    

### API Gateway 통합 대상
1. **Lambda**: REST API 백엔드로 가장 일반적인 사용
2. **HTTP 엔드포인트**: 기존 HTTP 백엔드에 기능 추가
3. **AWS 서비스**: SQS, Step Functions 등 다른 AWS 서비스와 연결
    - 예: Kinesis 스트림과 연결해 데이터 수집 → S3 저장


### API Gateway 배포 유형
1. **엣지 최적화**: CloudFront 경유, 글로벌 사용자 대상
2. **리전 배포**: 생성된 리전에서만 접근, 지연 시간 감소
3. **프라이빗 API**: VPC 내에서만 접근 가능
    

### API Gateway 보안
- **IAM 역할**: 내부 애플리케이션에 적합
- **Cognito**: 모바일/웹 사용자 인증
- **사용자 지정 권한 부여자**: Lambda로 인증 로직 구현
- **HTTPS 보안**: ACM 인증서 사용, 도메인 연결은 Route 53으로 설정
    

# 229. Cognito 코그니토 

- **Cognito**: 사용자에게 웹/앱과 상호작용할 수 있는 자격 증명을 부여
	- 대체로 사용자는 aws 밖에 있음. 
	- aws를 모르는 사용자에게 자격증명을 부여해 사용자를 인식 한다

- 코그니토 서비스 2개
	- 1. **Cognito 사용자 풀**: 사용자에게 가입 기능을 제공
		- **API Gateway**와 **애플리케이션 로드 밸런서(ALB)**와 원활히 통합
		- 웹 및 모바일 앱 사용자의 가입과 인증을 관리하는 서버리스 사용자 데이터베이스 
		- 이메일, 전화번호, 소셜 로그인(Facebook, Google 등)을 지원
	- 2. **Cognito 자격 증명 풀**: (=페더레이션 자격 증명 서비스): 사용자가 AWS 리소스에 액세스할 수 있도록 임시 AWS 자격 증명을 제공합니다.
		- API Gateway와 애플리케이션 로드 밸런서(ALB)로 접근하는게 아니라 "임시 AWS 자격증명을 사용해 AWS 계정에 직접 액세스함"

- **IAM에 이미 많은 사용자가 있지 않냐? ㅇㅇ
	- but 코드니토는 aws 외부의 웹/앱 서비스의 유저를 대상으로 한다. 
    
![[스크린샷 2025-05-14 오후 9.20.48.png]]

결론: 코그니토를 통해서 웹 및 모바일 애플리케이션의 사용자 관리와 보안이 강화되며,
AWS 리소스에 대한 안전한 액세스를 제공할 수 있다.


